# actionlint: allow-secrets ADMIN_TOKEN
name: admin-merge
on:
  workflow_dispatch:
    inputs:
      pr:
        description: PR number
        required: true
permissions:
  pull-requests: write
  contents: write
jobs:
  merge:
    runs-on: [self-hosted, Linux, X64, tiyf-vps]
    steps:
      - name: Merge PR
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            const prNumber = Number.parseInt('${{ inputs.pr }}', 10);
            if (!Number.isInteger(prNumber)) {
              core.setFailed('Invalid pull request number');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let pr;
            try {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              pr = data;
            } catch (error) {
              core.error(error);
              core.setFailed(`Failed to load PR #${prNumber}`);
              return;
            }

            const expectedHeadOid = pr.head?.sha;
            if (!expectedHeadOid) {
              core.setFailed('Missing head SHA on pull request');
              return;
            }

            const headlineRaw = `Merge PR #${prNumber}: ${pr.title ?? ''}`.trim();
            const headline = headlineRaw.length > 250 ? `${headlineRaw.slice(0, 247)}...` : (headlineRaw || `Merge PR #${prNumber}`);
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            // Wait for mergeable state to stabilise so we can tell if we just need an approval.
            let latestPr = pr;
            for (let attempt = 0; attempt < 5 && latestPr.mergeable_state === 'unknown'; attempt += 1) {
              await sleep(3000);
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              latestPr = data;
            }

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const prAuthor = latestPr.user?.login;
            const hasApproval = reviews.some(review => review.state === 'APPROVED' && review.user?.login && review.user.login !== prAuthor);

            if (!hasApproval) {
              const { data: authUser } = await github.rest.users.getAuthenticated();
              const authLogin = authUser?.login;

              if (authLogin && authLogin === prAuthor) {
                core.setFailed('Missing required approval and admin token matches PR author; manual reviewer needed.');
                return;
              }

              core.info('Submitting administrative approval to satisfy branch protection.');
              await github.rest.pulls.createReview({
                owner,
                repo,
                pull_number: prNumber,
                body: `Automated approval via admin merge workflow run ${process.env.GITHUB_RUN_ID ?? 'unknown'}`,
                event: 'APPROVE',
              });
            }

            // Re-fetch to capture any status updates and mergeability after approval.
            const { data: readyPr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

            try {
              const response = await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: prNumber,
                commit_title: headline,
                merge_method: 'squash',
                sha: expectedHeadOid,
              });

              if (!response?.data?.merged) {
                core.setFailed('REST merge request completed without merging the pull request');
                return;
              }

              const mergeCommit = response.data.sha ?? 'unknown commit';
              core.info(`PR #${prNumber} merged as ${mergeCommit}`);
            } catch (error) {
              if (error?.errors) {
                for (const err of error.errors) {
                  core.error(`${err.type ?? 'Error'}: ${err.message}`);
                }
              } else {
                core.error(error);
              }
              core.setFailed('Failed to merge pull request via REST API');
            }
