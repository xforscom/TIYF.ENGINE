# actionlint: allow-secrets ADMIN_TOKEN
name: admin-merge
on:
  workflow_dispatch:
    inputs:
      pr:
        description: PR number
        required: true
permissions:
  pull-requests: write
  contents: write
jobs:
  merge:
    runs-on: [self-hosted, Linux, X64, tiyf-vps]
    steps:
      - name: Merge PR
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        with:
          github-token: ${{ secrets.ADMIN_TOKEN }}
          script: |
            const prNumber = Number.parseInt('${{ inputs.pr }}', 10);
            if (!Number.isInteger(prNumber)) {
              core.setFailed('Invalid pull request number');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let pr;
            try {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              pr = data;
            } catch (error) {
              core.error(error);
              core.setFailed(`Failed to load PR #${prNumber}`);
              return;
            }

            const expectedHeadOid = pr.head?.sha;
            if (!expectedHeadOid) {
              core.setFailed('Missing head SHA on pull request');
              return;
            }

            const headlineRaw = `Merge PR #${prNumber}: ${pr.title ?? ''}`.trim();
            const headline = headlineRaw.length > 250 ? `${headlineRaw.slice(0, 247)}...` : (headlineRaw || `Merge PR #${prNumber}`);
            const bypassReasonRaw = `Admin merge via workflow run ${process.env.GITHUB_RUN_ID ?? 'unknown'}`;
            const bypassReason = bypassReasonRaw.length > 256 ? bypassReasonRaw.slice(0, 256) : bypassReasonRaw;

            const mutation = `mutation MergeAdminBypass($pullRequestId: ID!, $expectedHeadOid: GitObjectID!, $commitHeadline: String!, $bypassReason: String!) {
              mergePullRequest(input: {
                pullRequestId: $pullRequestId,
                expectedHeadOid: $expectedHeadOid,
                mergeMethod: SQUASH,
                commitHeadline: $commitHeadline,
                bypassPullRequestAllowances: true,
                bypassReason: $bypassReason
              }) {
                pullRequest {
                  merged
                  mergeCommit { oid }
                }
              }
            }`;

            try {
              const response = await github.graphql(mutation, {
                pullRequestId: pr.node_id,
                expectedHeadOid,
                commitHeadline: headline,
                bypassReason,
              });

              const mergeResult = response?.mergePullRequest?.pullRequest;
              if (!mergeResult?.merged) {
                core.setFailed('Merge mutation completed without merging the pull request');
                return;
              }

              const mergeCommit = mergeResult.mergeCommit?.oid ?? 'unknown commit';
              core.info(`PR #${prNumber} merged as ${mergeCommit}`);
            } catch (error) {
              if (error?.errors) {
                for (const err of error.errors) {
                  core.error(`${err.type ?? 'GraphQLError'}: ${err.message}`);
                }
              } else {
                core.error(error);
              }
              core.setFailed('Failed to merge pull request via GraphQL API');
            }
