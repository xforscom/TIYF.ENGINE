# actionlint: allow-secrets ADMIN_TOKEN
name: admin-branch-protection

on:
  workflow_dispatch:
    inputs:
      branch:
        description: Branch to protect
        default: main
        required: true
      checks:
        description: CSV of required status checks
        default: lint,m0-determinism,verify-strict,dataqa-tolerance,nightly-canary
        required: true
      reason:
        description: Why the protection update is requested
        required: false
        default: manual
      admin_token:
        description: Optional personal access token with admin permissions
        required: false
        default: ""
  push:
    branches:
      - main
    paths:
      - .github/workflows/admin-branch-protection.yml

permissions: {}

jobs:
  apply:
    runs-on: [self-hosted, Linux, X64, tiyf-vps]
    environment:
      name: ADMIN_TOKEN
    steps:
      - name: Configure branch protection
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b
        env:
          # actionlint: allow-secrets ADMIN_TOKEN
          ADMIN_TOKEN_FOR_WORKFLOW: ${{ secrets.ADMIN_TOKEN }}
        with:
          github-token: ${{ github.token }}
          script: |
            const defaultChecks = [
              'lint',
              'm0-determinism',
              'verify-strict',
              'dataqa-tolerance',
              'nightly-canary',
            ];

            const inputs = context.payload?.inputs ?? {};
            const branch = (inputs.branch ?? 'main').trim() || 'main';
            const checksCsv = (inputs.checks ?? '').trim();
            const manualToken = (inputs.admin_token ?? '').trim();
            const secretToken = (process.env.ADMIN_TOKEN_FOR_WORKFLOW ?? '').trim();
            const githubToken = (process.env.GITHUB_TOKEN ?? '').trim();
            let activeToken = secretToken || manualToken;

            if (!activeToken) {
              if (!githubToken) {
                core.setFailed('No admin token available. Configure the ADMIN_TOKEN secret or provide an admin_token input when manually dispatching.');
                return;
              }

              activeToken = githubToken;
              core.warning('Using the default GITHUB_TOKEN which may lack permissions to update branch protection.');
            }

            const contexts = (checksCsv ? checksCsv.split(',') : defaultChecks)
              .map((entry) => entry.trim())
              .filter(Boolean);
            if (contexts.length === 0) {
              core.setFailed('At least one status check must be provided.');
              return;
            }

            const adminGithub = activeToken === githubToken
              ? github
              : new github.constructor({ auth: activeToken });
            const { owner, repo } = context.repo;

            const payload = {
              required_status_checks: {
                strict: true,
                checks: contexts.map((context) => ({ context })),
              },
              enforce_admins: true,
              required_pull_request_reviews: {
                dismiss_stale_reviews: true,
                require_code_owner_reviews: false,
                required_approving_review_count: 1,
                require_last_push_approval: false,
              },
              restrictions: null,
              required_linear_history: false,
              allow_force_pushes: false,
              allow_deletions: false,
              block_creations: false,
              required_conversation_resolution: false,
              lock_branch: false,
              allow_fork_syncing: true,
            };

            try {
              await adminGithub.request('PUT /repos/{owner}/{repo}/branches/{branch}/protection', {
                owner,
                repo,
                branch,
                ...payload,
              });

              core.info(`Branch protection updated successfully for ${branch}.`);
            } catch (error) {
              const message = error?.message ?? String(error);
              const status = error?.status ?? error?.response?.status ?? 0;

              if (status === 403 && /resource not accessible by integration/i.test(message)) {
                core.warning(`Insufficient permissions to update branch protection (status ${status}). Skipping update.`);
                return;
              }

              throw error;
            }
